import * as os from 'os';
import * as path from 'path';
import * as fs from 'fs';

const TWINCLAW_HOME = '.twinclaw';

export function getProfileName(): string {
    const profile = process.env.TWINCLAW_PROFILE;
    if (profile && profile.trim().length > 0) {
        return profile.trim();
    }
    return 'default';
}

export function getWorkspaceDir(): string {
    const profile = getProfileName();
    const home = os.homedir();
    
    if (profile === 'default') {
        return path.join(home, TWINCLAW_HOME, 'workspace');
    }
    
    const sanitizedProfile = profile.replace(/[^a-zA-Z0-9_-]/g, '_');
    return path.join(home, TWINCLAW_HOME, `workspace-${sanitizedProfile}`);
}

export function getWorkspaceSubdir(subdir: string): string {
    return path.join(getWorkspaceDir(), subdir);
}

export function getConfigPath(): string {
    return path.join(getWorkspaceDir(), 'twinclaw.json');
}

export function getDatabasePath(): string {
    return path.join(getWorkspaceDir(), 'memory', 'twinclaw.db');
}

export function getIdentityDir(): string {
    return path.join(getWorkspaceDir(), 'identity');
}

export function getSecretsVaultPath(): string {
    return path.join(getWorkspaceDir(), 'secrets.sqlite');
}

export function getTranscriptsDir(): string {
    return path.join(getWorkspaceDir(), 'transcripts');
}

export function ensureWorkspaceDir(): void {
    const workspaceDir = getWorkspaceDir();
    if (!fs.existsSync(workspaceDir)) {
        fs.mkdirSync(workspaceDir, { recursive: true });
    }
}

export function ensureWorkspaceSubdirs(): void {
    ensureWorkspaceDir();
    
    const subdirs = ['memory', 'identity', 'transcripts'];
    for (const subdir of subdirs) {
        const fullPath = getWorkspaceSubdir(subdir);
        if (!fs.existsSync(fullPath)) {
            fs.mkdirSync(fullPath, { recursive: true });
        }
    }
}

export function getLegacyConfigPath(): string {
    return path.join(os.homedir(), TWINCLAW_HOME, 'twinclaw.json');
}

export function hasLegacyConfig(): boolean {
    const legacyPath = getLegacyConfigPath();
    const workspacePath = getConfigPath();
    
    return fs.existsSync(legacyPath) && !fs.existsSync(workspacePath);
}

export interface MigrationResult {
    migrated: boolean;
    sourcePath: string | null;
    targetPath: string | null;
    error?: string;
}

export function migrateLegacyConfig(): MigrationResult {
    const legacyPath = getLegacyConfigPath();
    const workspacePath = getConfigPath();
    
    if (!fs.existsSync(legacyPath)) {
        return { migrated: false, sourcePath: null, targetPath: null };
    }
    
    if (fs.existsSync(workspacePath)) {
        return { migrated: false, sourcePath: legacyPath, targetPath: workspacePath };
    }
    
    const workspaceDir = getWorkspaceDir();
    if (!fs.existsSync(workspaceDir)) {
        fs.mkdirSync(workspaceDir, { recursive: true });
    }
    
    try {
        const content = fs.readFileSync(legacyPath, 'utf-8');
        fs.writeFileSync(workspacePath, content, { encoding: 'utf-8', mode: 0o600 });
        
        const legacyDir = path.dirname(legacyPath);
        const legacyFiles = ['identity', 'memory', 'transcripts', 'secrets.sqlite'];
        
        for (const file of legacyFiles) {
            const legacyFile = path.join(legacyDir, file);
            if (fs.existsSync(legacyFile)) {
                const targetFile = path.join(workspaceDir, file);
                const targetFileDir = path.dirname(targetFile);
                if (!fs.existsSync(targetFileDir)) {
                    fs.mkdirSync(targetFileDir, { recursive: true });
                }
                
                if (fs.statSync(legacyFile).isDirectory()) {
                    fs.cpSync(legacyFile, targetFile, { recursive: true });
                } else {
                    fs.copyFileSync(legacyFile, targetFile);
                }
            }
        }
        
        return { migrated: true, sourcePath: legacyPath, targetPath: workspacePath };
    } catch (err) {
        const message = err instanceof Error ? err.message : String(err);
        return { migrated: false, sourcePath: legacyPath, targetPath: workspacePath, error: message };
    }
}

export const WORKSPACE_GITIGNORE = `# TwinClaw Workspace .gitignore
# Auto-generated by TwinClaw workspace initialization

# Sensitive databases
*.sqlite
*.sqlite-journal
*.sqlite-wal
*.sqlite-shm

# Secrets vault (never commit)
secrets.sqlite

# Memory databases
memory/*.db
memory/*.db-journal

# Session transcripts (may contain sensitive data)
transcripts/*.md

# Runtime state files
runtime-state.json
*.pid

# Logs
logs/
*.log

# Temporary files
*.tmp
*.temp
.cache/

# OS files
.DS_Store
Thumbs.db
`;

export function initializeWorkspaceGitignore(): boolean {
    const workspaceDir = getWorkspaceDir();
    const gitignorePath = path.join(workspaceDir, '.gitignore');
    
    if (fs.existsSync(gitignorePath)) {
        return false;
    }
    
    try {
        fs.writeFileSync(gitignorePath, WORKSPACE_GITIGNORE, { encoding: 'utf-8' });
        return true;
    } catch {
        return false;
    }
}

export function initializeWorkspace(): void {
    ensureWorkspaceSubdirs();
    initializeWorkspaceGitignore();
}

export function getWorkspaceSummary(): {
    workspaceDir: string;
    configPath: string;
    databasePath: string;
    identityDir: string;
    secretsVaultPath: string;
    transcriptsDir: string;
    profileName: string;
    exists: boolean;
} {
    const workspaceDir = getWorkspaceDir();
    return {
        workspaceDir,
        configPath: getConfigPath(),
        databasePath: getDatabasePath(),
        identityDir: getIdentityDir(),
        secretsVaultPath: getSecretsVaultPath(),
        transcriptsDir: getTranscriptsDir(),
        profileName: getProfileName(),
        exists: fs.existsSync(workspaceDir),
    };
}
